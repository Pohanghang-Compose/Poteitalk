# 노션에서 봐주세요 ~
https://marchbreeze.notion.site/JVM-18bb6895dba9809b8018ff9b37890e2f?pvs=4

---

# JVM 프로세스의 메모리 관리

![2025-01-31_23-29-24.jpg](attachment:5881ef55-9e83-4bd9-8563-778d0ec1f195:2025-01-31_23-29-24.jpg)

## 1. Runtime Data Area

- Runtime Data Area
    - JVM에서 Runtime에 Data를 올려놓는 공간
    - JVM이 프로그램을 실행할 때 사용되는 메모리 영역

      ![2025-01-31_23-21-53.jpg](attachment:6303b99c-eb07-49b4-8180-f3a39c8352e3:2025-01-31_23-21-53.jpg)


### (1) Method Area

- 특징
    - 앱이 시작될 때 필요한 클래스 로딩 정보가 할당되는 영역
    - 보통 JVM이 종료되거나 클래스 언로드가 일어나기 전까지 메모리에서 제거되지 않음
    - 모든 스레드에서 접근 가능함

- 저장 방법
    - 프로그램 실행 중 클래스나 인터페이스를 사용하게 되면, JVM은 Class Loader을 이용해 클래스와 인터페이스의 메타 데이터를 Method Area에 저장
    - 클래스가 로드 되는 시점 = 해당 클래스가 사용되기 위해 호출되는 시점
    - Byte Code → Class Loader → Method Area

- 저장되는 데이터 (메타 데이터)
    - 클래스 & 인터페이스 정보
    - 인스턴스 변수의 정보
    - 메서드의 모든 정보
    - Constant Pool : 상수 및 static으로 선언된 변수

      ⇒ companion object는 GC의 대상이 되지 않기 때문에 가벼운 객체만 참조해야 함 (메모리 누수 방지)


### (2) Stack Area

- 특징
    - 메서드가 호출될 시 할당되는 영역
        - 메서드 실행에 따라 자동으로 할당되고 해제됨
    - 메서드와 그에 관련된 지역 변수, 인자값, 리턴값 등이 저장됨
        - 스택 내부의 변수는 변수를 생성한 메서드가 실행되는 동안만 존재
    - 각 스레드는 하나의 고유한 Stack Area를 할당받음 (Thread-safe)
    - 안드로이드 운영 체제에서 관리, 메모리 할당 및 해제 속도가 빠름

- 저장 방법
    1. 원시 타입 변수 : Stack Area에 값 자체가 할당됨 (int, boolean, …)
    2. 나머지 : Heap 공간에 객체 데이터를 올리고 그 객체 데이터에 대한 참조값이 할당

### (3) Heap Area

- 특징
    - 프로그램이 실행되면서 동적으로 생성된 객체가 저장되는 영역
    - GC에 의해 메모리 관리
    - 메모리에서 가장 많은 공간을 차지
    - Stack Area에 비해 Heap Area에 값을 할당하고 해제하는 것은 많은 비용을 소모

- 저장 방법
    - 원시 타입이 아닌 경우 Stack 영역에는 참조값만 저장되며 Heap 영역에 실제 데이터가 저장

      ![2025-02-01_00-17-42.jpg](attachment:9435edf0-cf8a-4029-b9d1-5d815db5acc8:2025-02-01_00-17-42.jpg)


## 2. Garbage Collector (GC)

- GC
    - 사용하지 않는 메모리를 자동으로 회수하여, 사용 가능한 메모리를 확보해주는 메모리 관리 메커니즘
    - 메모리가 부족할 때 GC가 강제로 발생하여 사용하지 않는 객체를 제거하고 메모리를 확보


### (1) Mark-and-Sweep

- 안드로이드 초창기(5.0 Lollipop 이전) Dalvik VM에서 사용된 알고리즘

- 알고리즘
    1. Mark
        - 객체 그래프의 루트 노드부터 시작해 탐색하여 사용 중인 객체와 사용하지 않는 객체를 구분
        - 객체를 따라가며 참조가 있는 객체를 마킹
    2. Sweep
        - 마킹되지 않은, 즉 참조되지 않는 객체를 메모리에서 제거하여 가용 메모리를 확보

- 문제
    - STW (Stop-the-world) : GC가 도는 동안 모든 애플리케이션 스레드가 중단됨 → UI 끊김 문제 발생
    - 객체 생성 시점과 관계없이 전체 Heap을 한 번에 스캔 → 필요 이상의 스캔 비용 발생
    - Compact 단계의 부재 : 객체가 해제된 자리가 흩어져 연속된 큰 메모리 블록을 확보하기 어려움

### (2) Generational GC

- 5.0 이후 Dalvik VM에서 ART(Android Runtime)으로 전환되며 개선된 GC
    - Young Generation의 객체는 자주 회수되어 성능을 높일 수 있고, Old Generation의 객체는 비교적 덜 자주 회수하여 불필요한 작업을 줄임

- Weak Generational Hypothesis
    1. 대부분의 객체는 함수나 특정 로직이 끝나면 참조가 끊어지고, 짧은 시간 내에 GC 대상이 됨
    2. 오래된 객체에서 생성된지 별로 안 된 객체로의 참조는 아주 적게 존재

- Heap Memory 구조
    1. Young Generation
        - 새롭게 생성된 객체가 할당되는 공간
        - Young Generation에서 GC를 수행하면, 살아남은 객체만 Old Generation으로 승격
        - 3가지 공간으로 분리 : Eden 영역 / Survivor 영역 (2개, From & To)
    2. Old Generation
        - Young 영역에서 임계치(기본 31)보다 오래 살아남은 객체들이 넘어오는 영역
        - Young 영역보다 크게 할당하며, 크기가 큰 만큼 GC는 Young 영역에 비해 적게 발생

- Minor GC
    - Young Generation 만을 대상으로 진행
    1. 객체가 새로 생기면 Eden 영역에 할당
    2. Eden 영역이 꽉차면 살아있는 (reachable) 객체를 확인하고, To 영역으로 복사
    3. 복사 이후 Eden을 비우고, 복사된 객체의 Tenuring Threshold 값 +1 (From & To 이름 교체)

       ![2025-02-01_02-25-12.jpg](attachment:4d22a371-b0c4-4dca-a9cc-43c36f1003d9:2025-02-01_02-25-12.jpg)

    4. Threshold 값이 Max에 도달한 객체는 Old Generation 영역으로 승격

       ![2025-02-01_02-25-42.jpg](attachment:9d85c9dc-a2cc-4024-9d3f-33fe6bbf91bf:2025-02-01_02-25-42.jpg)

       ![2025-02-01_02-26-16.jpg](attachment:13049bdb-2c09-4f85-9c4c-39c94d7a18ae:2025-02-01_02-26-16.jpg)


- Major GC
    - 전체 Heap (Young + Old Generation) 대상으로 수행
    - 발생 시점
        - 힙 사용률이 임계치에 도달 (Young GC를 반복해도 메모리가 충분히 확보되지 않는 경우)
        - Old Generation 영역에 많은 객체가 유입되는 경우
        - 기기 전체에서 메모리 부족 상황이 발생하거나, 다른 프로세스/서비스에 메모리가 필요한 경우

### (3) Concurrent Mark-and-Sweep (CMS)

- CMS GC
    - 기존 Major GC : STW 발생 → GC 스레드를 제외한 나머지 스레드의 동작이 멈춤
    - Low Pause(Latency) Collector : STW 발생을 분산시켜 정지를 최소화하며 동시에 작업 수행 가능

- 동작 방식
    1. Initial Mark
        - STW가 발생하는 단계 (싱글 스레드 수행)
        - Old 영역에 있는 객체 중에 GC 루트 객체에서 직접 참조하는 객체 또는 Young 영역의 객체에서 참조하는 객체를 빠르게 마킹

          ![2025-02-01_02-53-09.jpg](attachment:72d12875-c879-4e61-88af-2ab00c9fcce8:2025-02-01_02-53-09.jpg)

    2. Concurrent Mark
        - Initial Mark 단계에서 마킹된 객체가 참조하는 객체를 대상으로 살아있는 객체를 추가 확인

          ![2025-02-01_02-53-57.jpg](attachment:66ee1cc0-6ee5-462a-b0c4-89aa341c3f4c:2025-02-01_02-53-57.jpg)

    3. Concurrent Proclean
        - 이전 단계가 애플리케이션과 동시에 실행되는 동안 일부 참조가 변경되는 경우를 대응
        - JVM은 힙 영역인 Card 중에 변형된 객체를 포함하는 Card를 “Dirty Card”로 표시
        - “Dirty Card”의 객체와 참조되는 객체도 마킹

          ![2025-02-01_02-54-48.jpg](attachment:7db54b5e-5d96-4a6c-86ed-dce23088d487:2025-02-01_02-54-48.jpg)

    4. Remark
        - STW가 발생하는 단계 (멀티 스레드 수행)
        - Concurrent Mark 과정에서 새롭게 추가된 GC 객체 존재 여부 검증하는 단계
        - 일반적으로 Young 영역이 비어있을 때 실행해서 최대한 STW이 적게 발생하도록 함
    5. Concurrent Sweep
        - 마킹되지 않은 객체 메모리에서 제거

          ![2025-02-01_02-57-04.jpg](attachment:72e91a1d-9ed2-465d-b196-1c7ca743b575:2025-02-01_02-57-04.jpg)


# OS 레벨의 메모리 관리

## 1. Android 메모리 유형

- 3가지 메모리 유형 : RAM, zRAM, 저장소 → CPU와 GPU는 모두 동일한 RAM에 액세스

  ![2025-02-01_03-23-23.jpg](attachment:8049082f-8780-49a9-a78e-482fd7888401:2025-02-01_03-23-23.jpg)


1. RAM
    - 앱과 안드로이드 시스템이 실행되는 주 메모리로, 전원이 꺼지면 데이터가 사라지는 휘발성 메모리
    - 가장 빠른 메모리 유형이지만 일반적으로 크기가 제한됨
    - 속도가 빠르고 접근 시간이 짧아, 코드 실행이나 런타임 데이터(객체, 스택 등)를 저장하기에 적합
2. zRAM
    - 물리적 RAM의 일부를 **압축 스왑 공간**처럼 사용하는 기법
    - 모든 것은 zRAM에 배치될 때 압축되고 zRAM에서 복사될 때 압축이 해제
    - RAM 일부를 zRAM 파티션으로 잡아두고, 우선순위가 낮은 메모리 페이지를 **압축 상태**로 보관
3. 저장소
    - 파일 시스템, 그리고 모든 앱 및 라이브러리, 플랫폼에 포함된 객체 코드와 같은 영구 데이터가 모두 포함
    - 다른 두 메모리 유형보다 용량이 훨씬 큼

## 2. 메모리 부족 관리

### (1) 메모리 페이지

- 메모리 페이지
    - 시스템 메모리를 효율적으로 관리하기 위해 **RAM을 일정 크기 단위로 나눈 최소 관리 단위**
    - 일반적으로 각 페이지 = 4KB 메모리

1. Free Page
    - 현재 전혀 사용되지 않는 RAM 영역 → 새로운 프로세스나 객체 할당 시 즉시 사용할 수 있음
    - 메모리가 부족하면, 사용 중인 페이지(특히 캐시 페이지) 등을 정리해서 Free Page를 늘림

1. Used Page
    1. Cached Memory
        - 저장소의 파일로 지원되는 메모리
        1. Private ↔ Shared : 하나의 프로세스에서만 소유하는지의 여부
        2. Clean ↔ Dirty : 페이지의 수정 여부
    2. Anonumous Memory
        - 저장소의 파일로 지원되지 않는 메모리 (연결 X)
        - 초기 상태부터 파일로 매핑되지 않았기 때문에, 변경된 내용을 디스크에 쓰는 백업 과정이 기본적으로 존재하지 않음
        - Dirty Page로 간주

### (2) 커널 스왑 데몬

- 커널 스왑 데몬 (kswapd)
    - 자동으로 동작하여 메모리를 확보(회수)하는 백그라운드 커널 스레드
    - 기기의 사용 가능한 메모리가 부족해질 때 활성화
    - Linux 커널의 일부 : 사용 가능한 메모리의 낮은 임계값과 높은 임계값을 유지
        - 사용 가능한 메모리가 낮은 임계값 아래로 떨어지면 kswapd가 메모리를 회수하기 시작
        - 사용 가능한 메모리가 높은 임계값에 도달하면 kswapd가 메모리 회수를 중지

- 동작 방식
    1. Demand Paging
        - 클린 페이지 제거
        1. 메모리 부족 시 클린 페이지(저장소와 동일한 데이터)를 삭제하여 Free Page 확보
        2. 프로세스가 삭제한 데이터에 접근 시도 시, **저장소에서 다시 읽어와 RAM에 적재**
    2. zRAM 압축
        - 더티 페이지 제거
        1. 더티 페이지의 경우 삭제할 수 없으므로, zRAM으로 압축하며 Swap-Out을 진행
        2. 프로세스가 zRAM의 더티 페이지 접근 시도 시, 페이지가 압축 해제되고 다시 RAM으로 이동
        3. 압축된 페이지와 연결된 프로세스가 종료되면 페이지가 zRAM에서 삭제됨

- Low Memory Killer
    - kswapd 방식으로는 시스템에 충분한 메모리를 확보할 수 없는 경우
    - 커널에서 메모리 확보를 위해 프로세스를 우선순위에 따라 종료